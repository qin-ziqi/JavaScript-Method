<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>排序算法比较</title>
</head>

<body>
    <h2>排序算法比较</h2>
    <script>
        const times = 100; //算法重复执行的此属
        const length = 1000; //算法的数组长度
        /**
         * 获取随机数组
         */
        function getArray() {
            const array = [];
            for (let i = 0; i < length; i++) {
                const num = Math.floor(Math.random() * length);
                array.push(num);
            }
            return array;
        }

        /**
         * 执行100次所需的总时间(减小因随机数组带来的干扰)
         * 
         * @param {string} desc 冒泡算法描述
         * @param {function} fn 需要执行的冒泡算法
         */
        function getAllTime(desc, fn) {
            console.time(desc);
            for (let i = 0; i < times; i++) {
                const array = getArray();
                fn(array);
            }
            console.timeEnd(desc);
        }

        console.log('/*---------- 1.冒泡排序 ----------*/');
        /**
         * 原始版冒泡排序
         * 
         * @param {array} arr 需要排序的数组
         */
        function bubble1(arr) {
            const len = arr.length;
            for (let i = 0; i < len; i++) {
                for (let j = 0; j < len - 1 - i; j++) {
                    if (arr[j] > arr[j + 1]) { //相邻元素两两对比 
                        const temp = arr[j + 1]; //元素交换
                        arr[j + 1] = arr[j];
                        arr[j] = temp;
                    }
                }
            }
        }
        getAllTime('原始版冒泡排序', bubble1);

        /**
         * 进化版冒泡排序
         * 
         * @param {array} arr 需要排序的数组
         */
        function bubble2(arr) {
            let i = arr.length - 1; //初始时，最后位置保持不变
            while (i > 0) {
                let pos = 0; //每趟开始时，无记录交换
                for (let j = 0; j < i; j++) {
                    if (arr[j] > arr[j + 1]) {
                        pos = j; //记录交换的位置
                        const temp = arr[j];
                        arr[j] = arr[j + 1];
                        arr[j + 1] = temp;
                    }
                }
                i = pos; //为下一趟排序做准备
            }
        }
        getAllTime('进化版冒泡排序', bubble2);

        /**
         * 升级版冒泡排序
         * 
         * @param {array} arr 需要排序的数组
         */
        function bubble3(arr) {
            let high = arr.length - 1; //设置变量的初始值
            let low = 0;
            let j;
            while (low < high) {
                for (j = low; j < high; ++j) { //正向冒泡，找到最大者
                    if (arr[j] > arr[j + 1]) {
                        const temp = arr[j];
                        arr[j] = arr[j + 1];
                        arr[j + 1] = temp;
                    }
                }
                --high; //修改high的值，前移一位
                for (j = high; j > low; --j) { //反向冒泡，找到最小值
                    if (arr[j] < arr[j - 1]) {
                        const temp = arr[j];
                        arr[j] = arr[j - 1];
                        arr[j - 1] = temp;
                    }
                }
                ++low; //修改low的值，后移一位
            }
        }
        getAllTime('升级版冒泡排序', bubble3);

        /**
         * 自创版冒泡排序
         * 
         * @param {array} arr 需要排序的数组
         */
        function bubble4(arr) {
            let low = 0;
            let high = arr.length - 1; //设置变量的初始值
            let j;
            while (low < high) {
                let pos1 = 0;
                let pos2 = 0;
                for (let i = low; i < high; ++i) { //正向冒泡，找到最大值
                    if (arr[i] > arr[i + 1]) {
                        const temp = arr[i];
                        arr[i] = arr[i + 1];
                        arr[i + 1] = temp;
                        pos1 = i;
                    }
                }
                high = pos1; //记录上次位置
                for (let j = high; j > low; --j) { //反向冒泡，找到最小值
                    if (arr[j] < arr[j - 1]) {
                        const temp = arr[j];
                        arr[j] = arr[j - 1];
                        arr[j - 1] = temp;
                        pos2 = j;
                    }
                }
                low = pos2; //修改low值
            }
        }
        getAllTime('自创版冒泡排序', bubble4);

        console.log('/*---------- 2.选择排序 ----------*/');
        /**
         * 初始版选择排序
         * 
         * @param {array} arr 需要排序的数组
         */
        function select1(arr) {
            const len = arr.length;
            for (let i = 0; i < len; i++) {
                for (let j = i + 1; j < len; j++) {
                    if (arr[j] < arr[i]) {
                        const temp = arr[i];
                        arr[i] = arr[j];
                        arr[j] = temp;
                    }
                }
            }
        }
        getAllTime('初始版选择排序', select1);

        /**
         * 升级版选择排序
         * 
         * @param {array} arr 需要排序的数组
         */
        function select2(arr) {
            const len = arr.length;
            let minIndex;
            for (let i = 0; i < len - 1; i++) {
                minIndex = i;
                for (let j = i + 1; j < len; j++) {
                    if (arr[j] < arr[minIndex]) { //寻找最小的数
                        minIndex = j; //将最小数的索引保存
                    }
                }
                const temp = arr[i];
                arr[i] = arr[minIndex];
                arr[minIndex] = temp;
            }
        }
        getAllTime('升级版选择排序', select2);

        console.log('/*---------- 3.插入排序 ----------*/');
        /**
         * 初始版插入排序
         * 
         * @param {array} arr 需要排序的数组
         */
        function insert1(arr) {
            const len = arr.length;
            for (let i = 1; i < len; i++) {
                const temp = arr[i];
                let j = i - 1;
                while (arr[j] > temp) {
                    arr[j + 1] = arr[j];
                    j--;
                }
                arr[j + 1] = temp;
            }
        }
        getAllTime('初始版插入排序', insert1);

        /**
         * 二分法插入排序
         * 
         * @param {array} arr 需要排序的数组
         */
        function insert2(arr) {
            const len = arr.length;
            for (let i = 1; i < len; i++) {
                const temp = arr[i];
                let left = 0;
                let right = i - 1;
                while (left <= right) {
                    let middle = parseInt((left + right) / 2);
                    if (temp < arr[middle]) {
                        right = middle - 1;
                    } else {
                        left = middle + 1;
                    }
                }
                for (let j = i - 1; j >= left; j--) {
                    arr[j + 1] = arr[j];
                }
                arr[left] = temp;
            }
        }
        getAllTime('二分法插入排序 ', insert2);
    </script>
</body>

</html>